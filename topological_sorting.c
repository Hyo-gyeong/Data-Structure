//위상정렬
#include <stdio.h>
#include <stdlib.h>
#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 50

//스택--------------------------------------------------- 
#define MAX_STACK_SIZE 100
typedef int element;
typedef struct {
	element stack[MAX_STACK_SIZE];
	int top;
}StackType;

//그래프의 연결리스트 표현--------------------------------
typedef struct GraphNode
{
	int vertex;
	struct GraphNode *link;
}GraphNode;

typedef struct GraphType 
{
	int n; // 정점의 개수
	GraphNode *adj_list[MAX_VERTICES];
}GraphType;

// 그래프 초기화
void graph_init(GraphType *g) 
{
	int i;
	g->n = 0;
	for (i = 0; i < MAX_VERTICES; i++)
		g->adj_list[i] = NULL;
}

// 정점 삽입 연산
void insert_vertex(GraphType *g, int v)
 {
	 if (g->n + 1 > MAX_VERTICES){
		 printf("정점 개수 초과\n");
		 return;
	 }
	 g->n++;
 }

// 간선 삽입 연산, v를 u의 인접 리스트에 삽입한다.
void insert_edge(GraphType *g, int u, int v)
{
	GraphNode *node;

	if( u >= g->n || v >= g->n ){
		fprintf(stderr, "그래프: 정점 번호 오류");		
		return;
	}
	node = (GraphNode *)malloc(sizeof(GraphNode));
	node->vertex = v;
	node->link = g->adj_list[u];
	g->adj_list[u] = node;
}

void remove_node(GraphNode **phead, element item) // 4장 리스트에서 학습한 함수에서 ListNode --> GraphNode로 변경했음
{
	GraphNode *p, *prevp;
     
     if (*phead == NULL)
          printf("리스트는 비어있습니다.\n");
     else if ((*phead)->vertex == item) {
          p = *phead;
          *phead = (*phead)->link;
          free(p);
     }
     else {
          p = *phead;
          do {
               prevp = p;
               p = p->link;
          }while (p != NULL && p->vertex != item);
          if (p != NULL) {
               prevp->link = p->link;
               free(p);
          }
          else
               printf("%d은 리스트에 없음\n", item);
     }
}
//스택 초기화
void init(StackType *s)
{
	s->top = -1; 
}
int is_empty(StackType *s)
{
	return (s->top == -1); 
}
int is_full(StackType *s)
{
	if (!is_full(s)){
		return (s->top == (MAX_STACK_SIZE-1));
	}
}
// 삽입함수
void push(StackType *s, element item) 
{
	s->stack[++(s->top)] = item;
}
// 삭제함수
element pop(StackType *s) 
{
	if (!is_empty(s)){
		return s->stack[(s->top)--];
	}
}
// 피크함수
element peek(StackType *s) 
{
	if( is_empty(s) ) {
		 fprintf(stderr, "스택 공백 에러\n");
		 return;
	 }
	 else
		return s->stack[s->top];
}
// 위상정렬을 수행한다.
int topo_sort(GraphType *g)
{
	 int i;
	 StackType s;
	 GraphNode *node;

	 // 모든 정점의 진입 차수를 계산
	 int *in_degree = (int *)malloc(g->n* sizeof(int));
	 for (i = 0; i < g->n; i++) // 초기화
		in_degree[i] = 0;
	 for (i = 0; i < g->n; i++){
		for (node = g->adj_list[i]; node; node = node->link) //정점 i에서 나오는 간선들
			in_degree[node->vertex]++;
	 }

	 // 진입 차수가 0인 정점을 스택에 삽입
	 init(&s);
	 for (i = 0; i < g->n; i++) {
		if (in_degree[i] == 0) 
			push(&s, i);
	 }

	 // 위상 순서를 생성
	 while (!is_empty(&s)) {
		 int w;
		 w = pop(&s);
		 printf("정점 %d ->", w); //정점 출력
		 for (node = g->adj_list[w]; node; node = node->link) { //각 정점의 진입 차수를 변경
			int u = node->vertex;
			in_degree[u]--; //진입 차수를 감소
			if (in_degree[u] == 0) 
				push(&s, u);
		 }
	 }
	 free(in_degree);
}
int main(void)
{
	 GraphType g;
	 graph_init(&g);
	 insert_vertex(&g, 0);
	 insert_vertex(&g, 1);
	 insert_vertex(&g, 2);
	 insert_vertex(&g, 3);
	 insert_vertex(&g, 4);
	 insert_vertex(&g, 5);
	 //정점 0의 인접 리스트 생성
	 insert_edge(&g, 0, 2);
	 insert_edge(&g, 0, 3);
	 //정점 1의 인접 리스트 생성
	 insert_edge(&g, 1, 3);
	 insert_edge(&g, 1, 4);
	 //정점 2의 인접 리스트 생성
	 insert_edge(&g, 2, 3);
	 insert_edge(&g, 2, 5);
	 //정점 3의 인접 리스트 생성
	 insert_edge(&g, 3, 5);
	 //정점 4의 인접 리스트 생성
	 insert_edge(&g, 4, 5);
	 //위상 정렬
	 topo_sort(&g);
} 